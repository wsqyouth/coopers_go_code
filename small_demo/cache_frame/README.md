
### 缘由
最近一直在看设计模式, 发现单例模式在类似资源初始化时使用的非常多，于是实现一个框架代码。
需求要点：
* 基于接口而非实现，这样能够方便后续扩展
* 每个实现类内部类似于代理模式,资源句柄在init时进行初始化
* 单例模式的使用. 其实使用加载时初始化就行,chatgpt给出了懒汉式的once实现,非常厉害。


### 对话实现
Q1: 基于给定的cache接口，分别支持redis和memcache两种实现场景，其中内部各自包含成员client，使用代理模式实现以支持后续扩展。调用方使用单例模式获取实例变量，以进行后续业务工程。请给出完整设计代码，要求可扩展，并运行成功。不需要依赖第三方库，仅通过mock资源示例即可。

A1: 
这是一个很好的问题，让我们来设计这个系统。首先，我们需要定义我们的Cache接口，然后我们将创建两个结构体，一个用于Redis，另一个用于Memcache。每个结构体都将实现Cache接口。我们还将使用单例模式来确保每种类型的缓存只有一个实例。这是一个简单的示例，不包括错误处理和并发控制，这在实际生产环境中是必要的。



---
Q2: 请解释下，这里为什么要使用指针，而不是基本类型呢，各自的优劣在哪里
答: 这主要是因为指针可以提供对原始值的引用，而不是创建一个新的副本。这意味着，如果你修改了通过指针引用的值，那么原始值也会被修改。这在处理大型数据结构或者需要修改原始数据的情况下非常有用。然而，使用指针也需要更多的注意，因为如果指针没有被正确初始化，或者指向的内存已经被释放，那么使用指针可能会导致运行时错误。
---

Q3: 给出两种场景，各自封装一个函数里做成参考demo:
```
1. 如果val是字符串指针类型，set/get该如何使用
2. 如果val是结构体指针类型，set/get该如何使用
```
答: 由于我设计的Get方法直接将获取的数据填充到传入的data参数中。这需要使用到反射（reflection）来实现。
这个示例仍然有一些限制。例如，它只处理了指针和字符串类型，如果你需要支持其他类型，你需要为它们添加相应的条件。此外，这个示例假设r.data是一个string类型的值，实际上它可能是任何类型的值。为了更好地处理这些情况，你可以考虑使用gob或其他序列化库


---
Q4: 使用gob封装的反射进行实现
*RedisCache does not implement Cache (wrong type for Set method)
使用gob的方式见cache_plugin_v2.go

我们使用gob包来实现Set和Get方法。Set方法中，我们使用gob.NewEncoder来创建一个新的gob.Encoder实例，并将数据编码为字节切片。Get方法中，我们使用gob.NewDecoder来创建一个新的gob.Decoder实例，并将字节切片解码为data参数所指定的类型。
这样，我们就不需要手动使用反射了，而是依赖gob包来处理类型和结构的问题。