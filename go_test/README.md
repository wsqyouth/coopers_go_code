### 单测命令：
// 利用生成的文件查看哪些被覆盖
go test -v -coverprofile=test.out -gcflags=all=-l
go tool cover -html=test.out -o test.html


// 查看覆盖率
go test  -gcflags=-l -cover

// 指定函数单测
 go test  -gcflags=-l -run  TestIsInUint32



### 笔记
单测中有个所谓的3A原则：
•  Arrange：初始化测试对象或者准备测试数据
•  Act：调用被测方法
•  Assert：断言
返回到这个简单地例子中，其实就对应生成测试用例、遍历所有测试用例、以及断言函数输出。

---
一般来说可以分成基于需求和基于实现，又分别基本等价于黑盒法和白盒法。
黑盒：对待测单元的具体实现并不关心，只关心其实现了什么功能，或者说其输入输出是什么。
白盒：知晓待测单元的所有细节，并根据这些细节一个一个的去设计测试用例。

其实白盒法做起来比较简单无脑，哪一行没有被覆盖到，就直接编一个测试用例去覆盖就好。
但其存在两个严重的问题，一是容易在写单测上消耗了太多的时间，二是如果待测单元进行了一点小改动，哪怕并不影响整体的功能，也会对基于白盒的测试用例造成影响。

基于黑盒的用例主要是根据输入输出来设计的。常常考虑一下几个方面：边界值；特殊值；常规值等。
